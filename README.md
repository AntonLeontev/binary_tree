Бинарное дерево поиска на Ruby
==============
В последней версии реализованы два вида дерева: binary_tree_simple и binary_tree_uniq.

### Binary_tree_simple (class Node)

Не защищенное бинарное дерево, содержит два пустых ребенка дл каждого листа. Хранит повторяющиеся значения в отдельных узлах. 

#### Геттер

**tree_size** - показывает сколько значений хранит в себе дерево

#### Инстансные методы:

**store_number(n)** - добавляет в дерево значение n
**store_array(arr)** - добавляет в дерево массив значений
**show_in_order** - делает симметричный обход дерева, возвращая отсортированный массив исходных данных 
**clear** - очищает дерево, приводя его к исходному состоянию
**copy** - возвращает дубликат дерева
**contains?(n)** - определяет, содержит ли дерево значение n
**remove_node(n)** - удаляет узел со значением n 
***

### Binary_tree_uniq (class BinaryTree)

Эта версия бинарного дерева нужна для решения задачи, где нужно было для каждого элемента числового ряда определить сколько имеется справа чисел, меньших чем данное. оно предназначено только для хранения данных, но не для их редактирования.

Хранит только уникальные числа, записывая повторения в счетчик внутри узла.

Это позволяет исключить ассиметрию веток при большом количестве повторений одного значения, но не позволяет восстановить исходный порядок данных.

Дерево ведет учет общего количества сохраненных значений, минимального, максимального и суммы всех значений.

Обертка BinaryTree защищает узлы, делая их состояния полностью недоступными для изменения пользователями.

#### Геттеры

**numbers_stored** - показывает количество чисел, сохраненных в каждом узле
**sum** - показывает сумму всех чисел в дереве
**min_number** - показывает минимальное значение, хранящееся в дереве
**max_number** - показывает максимальное значение, хранящееся в дереве

#### Инстансные методы:

**store_number(n)** - добавляет в дерево значение n
**store_array(arr)** - добавляет в дерево массив значений
**show_in_order** - делает симметричный обход дерева, возвращая отсортированный массив исходных данных 
**clear** - очищает дерево, приводя его к исходному состоянию
**copy** - возвращает дубликат дерева
**contains?(n)** - определяет, содержит ли дерево значение n
***
